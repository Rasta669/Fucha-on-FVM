import { Protocol } from './enums';
import { CoinType } from './coinType';
export * from './coinType';
export * from './enums';
export interface AddressData {
    protocol: Protocol;
    payload: Uint8Array;
    coinType: CoinType;
    namespace?: number;
}
export declare class Address {
    readonly bytes: Uint8Array;
    readonly _coinType: CoinType;
    constructor(bytes: Uint8Array, coinType?: CoinType);
    network(): CoinType;
    coinType(): CoinType;
    protocol(): Protocol;
    payload(): Uint8Array;
    get namespace(): number;
    get subAddr(): Uint8Array;
    get subAddrHex(): string;
    /**
     * toString returns a string representation of this address. If no "coinType"
     * parameter was passed to the constructor the address will be prefixed with
     * the default coinType prefix "f" (mainnet).
     */
    toString(): string;
    /**
     * equals determines if this address is the "same" address as the passed
     * address. Two addresses are considered equal if they are the same instance
     * OR if their "bytes" property matches byte for byte.
     */
    equals(addr: Address): boolean;
}
export declare function bigintToArray(v: string | bigint | number): Uint8Array;
export declare function getChecksum(ingest: string | Uint8Array): Uint8Array;
export declare function validateChecksum(data: string | Uint8Array, checksum: Uint8Array): boolean;
export declare function newAddress(protocol: Protocol, payload: Uint8Array, coinType?: CoinType): Address;
export declare function newIDAddress(id: number | string, coinType?: CoinType): Address;
/**
 * newActorAddress returns an address using the Actor protocol.
 */
export declare function newActorAddress(data: Uint8Array, coinType?: CoinType): Address;
/**
 * newSecp256k1Address returns an address using the SECP256K1 protocol.
 */
export declare function newSecp256k1Address(pubkey: Uint8Array, coinType?: CoinType): Address;
/**
 * newBLSAddress returns an address using the BLS protocol.
 */
export declare function newBLSAddress(pubkey: Uint8Array, coinType?: CoinType): Address;
/**
 * newDelegatedAddress returns an address using the Delegated protocol.
 */
export declare function newDelegatedAddress(namespace: number, subAddr: Uint8Array, coinType?: CoinType): Address;
/**
 * newDelegatedEthAddress returns an address for eth using the Delegated protocol.
 */
export declare function newDelegatedEthAddress(ethAddr: string, coinType?: CoinType): Address;
export declare function decode(address: string): Address;
export declare function encode(coinType: string, address: Address): string;
export declare function newFromString(address: string): Address;
export declare function validateAddressString(addressString: string): boolean;
export declare function checkAddressString(address: string): AddressData;
/**
 * idFromAddress extracts the ID from an ID address.
 */
export declare function idFromAddress(address: Address): number;
/**
 * delegatedFromEthAddress derives the f410 address from an ethereum hex address
 */
export declare function delegatedFromEthAddress(ethAddr: string, coinType?: CoinType): string;
/**
 * ethAddressFromDelegated derives the ethereum address from an f410 address
 */
export declare function ethAddressFromDelegated(delegated: string): string;
/**
 * ethAddressFromID derives the ethereum address from an f0 address
 */
export declare function ethAddressFromID(idAddress: string): string;
declare const _default: {
    Address: typeof Address;
    newAddress: typeof newAddress;
    newIDAddress: typeof newIDAddress;
    newActorAddress: typeof newActorAddress;
    newSecp256k1Address: typeof newSecp256k1Address;
    newBLSAddress: typeof newBLSAddress;
    newFromString: typeof newFromString;
    bigintToArray: typeof bigintToArray;
    decode: typeof decode;
    encode: typeof encode;
    getChecksum: typeof getChecksum;
    validateChecksum: typeof validateChecksum;
    validateAddressString: typeof validateAddressString;
    checkAddressString: typeof checkAddressString;
    idFromAddress: typeof idFromAddress;
    delegatedFromEthAddress: typeof delegatedFromEthAddress;
    ethAddressFromDelegated: typeof ethAddressFromDelegated;
    CoinType: typeof CoinType;
    Protocol: typeof Protocol;
};
export default _default;
//# sourceMappingURL=index.d.ts.map