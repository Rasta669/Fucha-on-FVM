{"version":3,"sources":["../src/index.ts"],"names":["defaultCoinType","CoinType","MAIN","base32","coinTypes","Object","values","protocols","Protocol","filter","p","payloadHashLength","blsPublicKeyBytes","maxSubaddressLen","namespaceByteLen","Int64","toBuffer","length","maxInt64StringLength","checksumHashLength","ethAddressLength","addressHash","ingest","Address","bytes","coinType","Error","_coinType","protocol","slice","encode","addr","uint8arrays","equals","DELEGATED","payload","toNumber","toString","subAddr","bigintToArray","v","tmp","BigInt","fromString","getChecksum","validateChecksum","data","checksum","newAddress","protocolByte","leb","unsigned","concat","newIDAddress","id","ID","newActorAddress","ACTOR","newSecp256k1Address","pubkey","SECP256K1","newBLSAddress","BLS","newDelegatedAddress","namespace","MAX_INT","namespaceBuf","newDelegatedEthAddress","ethAddr","utils","isAddress","DelegatedNamespace","EVM","arrayify","decode","address","checkAddressString","prefix","subAddrBytes","namespaceByte","checksumBytes","newFromString","validateAddressString","addressString","error","includes","join","Number","raw","isNaN","splitIndex","indexOf","namespaceStr","subAddrCksmStr","subAddrCksmBytes","namespaceNumber","payloadCksm","idFromAddress","parseInt","delegatedFromEthAddress","TEST","ethAddressFromDelegated","delegated","getAddress","subAddrHex","ethAddressFromID","idAddress","buffer","ArrayBuffer","dataview","DataView","setUint8","setBigUint64","Uint8Array"],"mappings":"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","sourcesContent":["import * as leb from 'leb128'\nimport Int64 from 'node-int64'\nimport { blake2b } from 'blakejs'\nimport * as uint8arrays from 'uint8arrays'\nimport { utils } from 'ethers'\nimport { base32 as base32Function } from './base32'\nimport { DelegatedNamespace, Protocol } from './enums'\nimport { CoinType } from './coinType'\n\nexport * from './coinType'\nexport * from './enums'\n\nexport interface AddressData {\n  protocol: Protocol\n  payload: Uint8Array\n  coinType: CoinType\n  namespace?: number\n}\n\nconst defaultCoinType = CoinType.MAIN\nconst base32 = base32Function('abcdefghijklmnopqrstuvwxyz234567')\n\n// Store valid CoinTypes / Protocols for runtime validation\nconst coinTypes = Object.values(CoinType)\nconst protocols = Object.values(Protocol).filter(p => typeof p === 'number')\n\n// Defines the hash length taken over addresses\n// using the Actor and SECP256K1 protocols.\nconst payloadHashLength = 20\n\n// The length of a BLS public key\nconst blsPublicKeyBytes = 48\n\n// The maximum length of a delegated address's sub-address.\nconst maxSubaddressLen = 54\n\n// The number of bytes that are reserved for namespace\nconst namespaceByteLen = new Int64(0).toBuffer().length\n\n// The maximum length of `int64` as a string.\nconst maxInt64StringLength = 19\n\n// The hash length used for calculating address checksums.\nconst checksumHashLength = 4\n\n// The length of an Ethereum address in bytes\nconst ethAddressLength = 20\n\nfunction addressHash(ingest: Uint8Array): Uint8Array {\n  return blake2b(ingest, null, payloadHashLength)\n}\n\nexport class Address {\n  readonly bytes: Uint8Array\n  readonly _coinType: CoinType\n\n  constructor(bytes: Uint8Array, coinType: CoinType = defaultCoinType) {\n    if (!bytes || !bytes.length) throw new Error('Missing bytes in address')\n\n    this.bytes = bytes\n    this._coinType = coinType\n\n    if (!(this.protocol() in Protocol)) {\n      throw new Error(`Invalid protocol ${this.protocol()}`)\n    }\n  }\n\n  network(): CoinType {\n    return this._coinType\n  }\n\n  coinType(): CoinType {\n    return this._coinType\n  }\n\n  protocol(): Protocol {\n    return this.bytes[0]\n  }\n\n  payload(): Uint8Array {\n    return this.bytes.slice(1)\n  }\n\n  get namespace(): number {\n    if (this.protocol() !== Protocol.DELEGATED)\n      throw new Error('Can only get namespace for delegated addresses')\n    return new Int64(this.payload().slice(0, namespaceByteLen)).toNumber()\n  }\n\n  get subAddr(): Uint8Array {\n    if (this.protocol() !== Protocol.DELEGATED)\n      throw new Error('Can only get subaddress for delegated addresses')\n    return this.payload().slice(namespaceByteLen)\n  }\n\n  get subAddrHex(): string {\n    return uint8arrays.toString(this.subAddr, 'hex')\n  }\n\n  /**\n   * toString returns a string representation of this address. If no \"coinType\"\n   * parameter was passed to the constructor the address will be prefixed with\n   * the default coinType prefix \"f\" (mainnet).\n   */\n  toString(): string {\n    return encode(this._coinType, this)\n  }\n\n  /**\n   * equals determines if this address is the \"same\" address as the passed\n   * address. Two addresses are considered equal if they are the same instance\n   * OR if their \"bytes\" property matches byte for byte.\n   */\n  equals(addr: Address): boolean {\n    if (this === addr) {\n      return true\n    }\n    return uint8arrays.equals(this.bytes, addr.bytes)\n  }\n}\n\nexport function bigintToArray(v: string | bigint | number): Uint8Array {\n  let tmp = BigInt(v).toString(16)\n  if (tmp.length % 2 === 1) tmp = `0${tmp}`\n  return uint8arrays.fromString(tmp, 'base16')\n}\n\nexport function getChecksum(ingest: string | Uint8Array): Uint8Array {\n  return blake2b(ingest, null, checksumHashLength)\n}\n\nexport function validateChecksum(\n  data: string | Uint8Array,\n  checksum: Uint8Array\n): boolean {\n  return uint8arrays.equals(getChecksum(data), checksum)\n}\n\nexport function newAddress(\n  protocol: Protocol,\n  payload: Uint8Array,\n  coinType?: CoinType\n): Address {\n  const protocolByte = leb.unsigned.encode(protocol)\n  return new Address(uint8arrays.concat([protocolByte, payload]), coinType)\n}\n\nexport function newIDAddress(\n  id: number | string,\n  coinType?: CoinType\n): Address {\n  return newAddress(Protocol.ID, leb.unsigned.encode(id), coinType)\n}\n\n/**\n * newActorAddress returns an address using the Actor protocol.\n */\nexport function newActorAddress(\n  data: Uint8Array,\n  coinType?: CoinType\n): Address {\n  return newAddress(Protocol.ACTOR, addressHash(data), coinType)\n}\n\n/**\n * newSecp256k1Address returns an address using the SECP256K1 protocol.\n */\nexport function newSecp256k1Address(\n  pubkey: Uint8Array,\n  coinType?: CoinType\n): Address {\n  return newAddress(Protocol.SECP256K1, addressHash(pubkey), coinType)\n}\n\n/**\n * newBLSAddress returns an address using the BLS protocol.\n */\nexport function newBLSAddress(\n  pubkey: Uint8Array,\n  coinType?: CoinType\n): Address {\n  return newAddress(Protocol.BLS, pubkey, coinType)\n}\n\n/**\n * newDelegatedAddress returns an address using the Delegated protocol.\n */\nexport function newDelegatedAddress(\n  namespace: number,\n  subAddr: Uint8Array,\n  coinType?: CoinType\n): Address {\n  if (namespace > Int64.MAX_INT)\n    throw new Error('Namespace must be less than 2^63')\n\n  if (subAddr.length > maxSubaddressLen)\n    throw new Error('Subaddress address length')\n\n  const namespaceBuf = new Int64(namespace).toBuffer()\n\n  return newAddress(\n    Protocol.DELEGATED,\n    uint8arrays.concat([namespaceBuf, subAddr]),\n    coinType\n  )\n}\n\n/**\n * newDelegatedEthAddress returns an address for eth using the Delegated protocol.\n */\nexport function newDelegatedEthAddress(\n  ethAddr: string,\n  coinType?: CoinType\n): Address {\n  if (!utils.isAddress(ethAddr)) throw new Error('Invalid Ethereum address')\n\n  return newDelegatedAddress(\n    DelegatedNamespace.EVM,\n    utils.arrayify(ethAddr),\n    coinType\n  )\n}\n\nexport function decode(address: string): Address {\n  const { protocol, payload, coinType } = checkAddressString(address)\n  return newAddress(protocol, payload, coinType)\n}\n\nexport function encode(coinType: string, address: Address): string {\n  if (!address || !address.bytes) throw Error('Invalid address')\n\n  const protocol = address.protocol()\n  const payload = address.payload()\n  const prefix = `${coinType}${protocol}`\n\n  switch (protocol) {\n    case Protocol.ID: {\n      return `${prefix}${leb.unsigned.decode(payload)}`\n    }\n    case Protocol.DELEGATED: {\n      const namespace = address.namespace\n      const subAddrBytes = address.subAddr\n      const protocolByte = leb.unsigned.encode(protocol)\n      const namespaceByte = leb.unsigned.encode(namespace)\n      const checksumBytes = getChecksum(\n        uint8arrays.concat([protocolByte, namespaceByte, subAddrBytes])\n      )\n\n      const bytes = uint8arrays.concat([subAddrBytes, checksumBytes])\n      return `${prefix}${namespace}f${base32.encode(bytes)}`\n    }\n    default: {\n      const checksum = getChecksum(address.bytes)\n      const bytes = uint8arrays.concat([payload, checksum])\n      return `${prefix}${base32.encode(bytes)}`\n    }\n  }\n}\n\nexport function newFromString(address: string): Address {\n  return decode(address)\n}\n\nexport function validateAddressString(addressString: string): boolean {\n  try {\n    checkAddressString(addressString)\n    return true\n  } catch (error) {\n    return false\n  }\n}\n\nexport function checkAddressString(address: string): AddressData {\n  if (typeof address !== 'string' || address.length < 3)\n    throw Error('Address should be a string of at least 3 characters')\n\n  const coinType = address[0] as CoinType\n  if (!coinTypes.includes(coinType))\n    throw Error(`Address cointype should be one of: ${coinTypes.join(', ')}`)\n\n  const protocol = Number(address[1]) as Protocol\n  if (!protocols.includes(protocol))\n    throw Error(`Address protocol should be one of: ${protocols.join(', ')}`)\n\n  const raw = address.slice(2)\n\n  switch (protocol) {\n    case Protocol.ID: {\n      if (raw.length > maxInt64StringLength)\n        throw Error('Invalid ID address length')\n      if (isNaN(Number(raw))) throw Error('Invalid ID address')\n      const payload = leb.unsigned.encode(raw)\n      return { protocol, payload, coinType }\n    }\n\n    case Protocol.DELEGATED: {\n      const splitIndex = raw.indexOf('f')\n      if (splitIndex === -1) throw new Error('Invalid delegated address')\n\n      const namespaceStr = raw.slice(0, splitIndex)\n      if (namespaceStr.length > maxInt64StringLength)\n        throw new Error('Invalid delegated address namespace')\n\n      const subAddrCksmStr = raw.slice(splitIndex + 1)\n      const subAddrCksmBytes = base32.decode(subAddrCksmStr)\n      if (subAddrCksmBytes.length < checksumHashLength)\n        throw Error('Invalid delegated address length')\n\n      const subAddrBytes = subAddrCksmBytes.slice(0, -checksumHashLength)\n      const checksumBytes = subAddrCksmBytes.slice(subAddrBytes.length)\n      if (subAddrBytes.length > maxSubaddressLen)\n        throw Error('Invalid delegated address length')\n\n      const protocolByte = leb.unsigned.encode(protocol)\n      const namespaceNumber = Number(namespaceStr)\n      const namespaceByte = leb.unsigned.encode(namespaceNumber)\n      const bytes = uint8arrays.concat([\n        protocolByte,\n        namespaceByte,\n        subAddrBytes\n      ])\n\n      if (!validateChecksum(bytes, checksumBytes))\n        throw Error('Invalid delegated address checksum')\n\n      const namespaceBuf = new Int64(namespaceNumber).toBuffer()\n      const payload = uint8arrays.concat([namespaceBuf, subAddrBytes])\n      return { protocol, payload, coinType, namespace: namespaceNumber }\n    }\n\n    case Protocol.SECP256K1:\n    case Protocol.ACTOR:\n    case Protocol.BLS: {\n      const payloadCksm = base32.decode(raw)\n      if (payloadCksm.length < checksumHashLength)\n        throw Error('Invalid address length')\n\n      const payload = payloadCksm.slice(0, -checksumHashLength)\n      const checksum = payloadCksm.slice(payload.length)\n\n      if (protocol === Protocol.SECP256K1 || protocol === Protocol.ACTOR)\n        if (payload.length !== payloadHashLength)\n          throw Error('Invalid address length')\n\n      if (protocol === Protocol.BLS)\n        if (payload.length !== blsPublicKeyBytes)\n          throw Error('Invalid address length')\n\n      const protocolByte = leb.unsigned.encode(protocol)\n      const bytes = uint8arrays.concat([protocolByte, payload])\n      if (!validateChecksum(bytes, checksum))\n        throw Error('Invalid address checksum')\n\n      return { protocol, payload, coinType }\n    }\n\n    default:\n      throw Error(`Invalid address protocall: ${protocol}`)\n  }\n}\n\n/**\n * idFromAddress extracts the ID from an ID address.\n */\nexport function idFromAddress(address: Address): number {\n  if (address.protocol() !== Protocol.ID)\n    throw new Error('Cannot get ID from non ID address')\n  // An unsigned varint should be less than 2^63 which is < Number.MAX_VALUE.\n  // So this number SHOULD be representable in JS and safe to parseInt.\n  // https://github.com/multiformats/unsigned-varint\n  // TODO: does leb128 enforce the max value?\n  return parseInt(leb.unsigned.decode(address.payload()), 10)\n}\n\n/**\n * delegatedFromEthAddress derives the f410 address from an ethereum hex address\n */\n\nexport function delegatedFromEthAddress(\n  ethAddr: string,\n  coinType: CoinType = CoinType.TEST\n): string {\n  return newDelegatedEthAddress(ethAddr, coinType).toString()\n}\n\n/**\n * ethAddressFromDelegated derives the ethereum address from an f410 address\n */\n\nexport function ethAddressFromDelegated(delegated: string): string {\n  return utils.getAddress(`0x${decode(delegated).subAddrHex}`)\n}\n\n/**\n * ethAddressFromID derives the ethereum address from an f0 address\n */\n\nexport function ethAddressFromID(idAddress: string): string {\n  const address = decode(idAddress)\n  const id = idFromAddress(address)\n  const buffer = new ArrayBuffer(ethAddressLength)\n  const dataview = new DataView(buffer)\n  dataview.setUint8(0, 255)\n  dataview.setBigUint64(12, BigInt(id), false)\n  return `0x${uint8arrays.toString(new Uint8Array(buffer), 'hex')}`\n}\n\nexport default {\n  Address,\n  newAddress,\n  newIDAddress,\n  newActorAddress,\n  newSecp256k1Address,\n  newBLSAddress,\n  newFromString,\n  bigintToArray,\n  decode,\n  encode,\n  getChecksum,\n  validateChecksum,\n  validateAddressString,\n  checkAddressString,\n  idFromAddress,\n  delegatedFromEthAddress,\n  ethAddressFromDelegated,\n  CoinType,\n  Protocol\n}\n"],"file":"index.js"}