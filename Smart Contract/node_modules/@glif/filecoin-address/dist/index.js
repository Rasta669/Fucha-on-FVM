"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  Address: true,
  bigintToArray: true,
  getChecksum: true,
  validateChecksum: true,
  newAddress: true,
  newIDAddress: true,
  newActorAddress: true,
  newSecp256k1Address: true,
  newBLSAddress: true,
  newDelegatedAddress: true,
  newDelegatedEthAddress: true,
  decode: true,
  encode: true,
  newFromString: true,
  validateAddressString: true,
  checkAddressString: true,
  idFromAddress: true,
  delegatedFromEthAddress: true,
  ethAddressFromDelegated: true,
  ethAddressFromID: true
};
exports.Address = void 0;
exports.bigintToArray = bigintToArray;
exports.checkAddressString = checkAddressString;
exports.decode = decode;
exports["default"] = void 0;
exports.delegatedFromEthAddress = delegatedFromEthAddress;
exports.encode = encode;
exports.ethAddressFromDelegated = ethAddressFromDelegated;
exports.ethAddressFromID = ethAddressFromID;
exports.getChecksum = getChecksum;
exports.idFromAddress = idFromAddress;
exports.newActorAddress = newActorAddress;
exports.newAddress = newAddress;
exports.newBLSAddress = newBLSAddress;
exports.newDelegatedAddress = newDelegatedAddress;
exports.newDelegatedEthAddress = newDelegatedEthAddress;
exports.newFromString = newFromString;
exports.newIDAddress = newIDAddress;
exports.newSecp256k1Address = newSecp256k1Address;
exports.validateAddressString = validateAddressString;
exports.validateChecksum = validateChecksum;

var leb = _interopRequireWildcard(require("leb128"));

var _nodeInt = _interopRequireDefault(require("node-int64"));

var _blakejs = require("blakejs");

var uint8arrays = _interopRequireWildcard(require("uint8arrays"));

var _ethers = require("ethers");

var _base = require("./base32");

var _enums = require("./enums");

Object.keys(_enums).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _enums[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _enums[key];
    }
  });
});

var _coinType = require("./coinType");

Object.keys(_coinType).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _coinType[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _coinType[key];
    }
  });
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var defaultCoinType = _coinType.CoinType.MAIN;
var base32 = (0, _base.base32)('abcdefghijklmnopqrstuvwxyz234567'); // Store valid CoinTypes / Protocols for runtime validation

var coinTypes = Object.values(_coinType.CoinType);
var protocols = Object.values(_enums.Protocol).filter(function (p) {
  return typeof p === 'number';
}); // Defines the hash length taken over addresses
// using the Actor and SECP256K1 protocols.

var payloadHashLength = 20; // The length of a BLS public key

var blsPublicKeyBytes = 48; // The maximum length of a delegated address's sub-address.

var maxSubaddressLen = 54; // The number of bytes that are reserved for namespace

var namespaceByteLen = new _nodeInt["default"](0).toBuffer().length; // The maximum length of `int64` as a string.

var maxInt64StringLength = 19; // The hash length used for calculating address checksums.

var checksumHashLength = 4; // The length of an Ethereum address in bytes

var ethAddressLength = 20;

function addressHash(ingest) {
  return (0, _blakejs.blake2b)(ingest, null, payloadHashLength);
}

var Address = /*#__PURE__*/function () {
  function Address(bytes) {
    var coinType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultCoinType;

    _classCallCheck(this, Address);

    _defineProperty(this, "bytes", void 0);

    _defineProperty(this, "_coinType", void 0);

    if (!bytes || !bytes.length) throw new Error('Missing bytes in address');
    this.bytes = bytes;
    this._coinType = coinType;

    if (!(this.protocol() in _enums.Protocol)) {
      throw new Error("Invalid protocol ".concat(this.protocol()));
    }
  }

  _createClass(Address, [{
    key: "network",
    value: function network() {
      return this._coinType;
    }
  }, {
    key: "coinType",
    value: function coinType() {
      return this._coinType;
    }
  }, {
    key: "protocol",
    value: function protocol() {
      return this.bytes[0];
    }
  }, {
    key: "payload",
    value: function payload() {
      return this.bytes.slice(1);
    }
  }, {
    key: "toString",

    /**
     * toString returns a string representation of this address. If no "coinType"
     * parameter was passed to the constructor the address will be prefixed with
     * the default coinType prefix "f" (mainnet).
     */
    value: function toString() {
      return encode(this._coinType, this);
    }
    /**
     * equals determines if this address is the "same" address as the passed
     * address. Two addresses are considered equal if they are the same instance
     * OR if their "bytes" property matches byte for byte.
     */

  }, {
    key: "equals",
    value: function equals(addr) {
      if (this === addr) {
        return true;
      }

      return uint8arrays.equals(this.bytes, addr.bytes);
    }
  }, {
    key: "namespace",
    get: function get() {
      if (this.protocol() !== _enums.Protocol.DELEGATED) throw new Error('Can only get namespace for delegated addresses');
      return new _nodeInt["default"](this.payload().slice(0, namespaceByteLen)).toNumber();
    }
  }, {
    key: "subAddr",
    get: function get() {
      if (this.protocol() !== _enums.Protocol.DELEGATED) throw new Error('Can only get subaddress for delegated addresses');
      return this.payload().slice(namespaceByteLen);
    }
  }, {
    key: "subAddrHex",
    get: function get() {
      return uint8arrays.toString(this.subAddr, 'hex');
    }
  }]);

  return Address;
}();

exports.Address = Address;

function bigintToArray(v) {
  var tmp = BigInt(v).toString(16);
  if (tmp.length % 2 === 1) tmp = "0".concat(tmp);
  return uint8arrays.fromString(tmp, 'base16');
}

function getChecksum(ingest) {
  return (0, _blakejs.blake2b)(ingest, null, checksumHashLength);
}

function validateChecksum(data, checksum) {
  return uint8arrays.equals(getChecksum(data), checksum);
}

function newAddress(protocol, payload, coinType) {
  var protocolByte = leb.unsigned.encode(protocol);
  return new Address(uint8arrays.concat([protocolByte, payload]), coinType);
}

function newIDAddress(id, coinType) {
  return newAddress(_enums.Protocol.ID, leb.unsigned.encode(id), coinType);
}
/**
 * newActorAddress returns an address using the Actor protocol.
 */


function newActorAddress(data, coinType) {
  return newAddress(_enums.Protocol.ACTOR, addressHash(data), coinType);
}
/**
 * newSecp256k1Address returns an address using the SECP256K1 protocol.
 */


function newSecp256k1Address(pubkey, coinType) {
  return newAddress(_enums.Protocol.SECP256K1, addressHash(pubkey), coinType);
}
/**
 * newBLSAddress returns an address using the BLS protocol.
 */


function newBLSAddress(pubkey, coinType) {
  return newAddress(_enums.Protocol.BLS, pubkey, coinType);
}
/**
 * newDelegatedAddress returns an address using the Delegated protocol.
 */


function newDelegatedAddress(namespace, subAddr, coinType) {
  if (namespace > _nodeInt["default"].MAX_INT) throw new Error('Namespace must be less than 2^63');
  if (subAddr.length > maxSubaddressLen) throw new Error('Subaddress address length');
  var namespaceBuf = new _nodeInt["default"](namespace).toBuffer();
  return newAddress(_enums.Protocol.DELEGATED, uint8arrays.concat([namespaceBuf, subAddr]), coinType);
}
/**
 * newDelegatedEthAddress returns an address for eth using the Delegated protocol.
 */


function newDelegatedEthAddress(ethAddr, coinType) {
  if (!_ethers.utils.isAddress(ethAddr)) throw new Error('Invalid Ethereum address');
  return newDelegatedAddress(_enums.DelegatedNamespace.EVM, _ethers.utils.arrayify(ethAddr), coinType);
}

function decode(address) {
  var _checkAddressString = checkAddressString(address),
      protocol = _checkAddressString.protocol,
      payload = _checkAddressString.payload,
      coinType = _checkAddressString.coinType;

  return newAddress(protocol, payload, coinType);
}

function encode(coinType, address) {
  if (!address || !address.bytes) throw Error('Invalid address');
  var protocol = address.protocol();
  var payload = address.payload();
  var prefix = "".concat(coinType).concat(protocol);

  switch (protocol) {
    case _enums.Protocol.ID:
      {
        return "".concat(prefix).concat(leb.unsigned.decode(payload));
      }

    case _enums.Protocol.DELEGATED:
      {
        var namespace = address.namespace;
        var subAddrBytes = address.subAddr;
        var protocolByte = leb.unsigned.encode(protocol);
        var namespaceByte = leb.unsigned.encode(namespace);
        var checksumBytes = getChecksum(uint8arrays.concat([protocolByte, namespaceByte, subAddrBytes]));
        var bytes = uint8arrays.concat([subAddrBytes, checksumBytes]);
        return "".concat(prefix).concat(namespace, "f").concat(base32.encode(bytes));
      }

    default:
      {
        var checksum = getChecksum(address.bytes);

        var _bytes = uint8arrays.concat([payload, checksum]);

        return "".concat(prefix).concat(base32.encode(_bytes));
      }
  }
}

function newFromString(address) {
  return decode(address);
}

function validateAddressString(addressString) {
  try {
    checkAddressString(addressString);
    return true;
  } catch (error) {
    return false;
  }
}

function checkAddressString(address) {
  if (typeof address !== 'string' || address.length < 3) throw Error('Address should be a string of at least 3 characters');
  var coinType = address[0];
  if (!coinTypes.includes(coinType)) throw Error("Address cointype should be one of: ".concat(coinTypes.join(', ')));
  var protocol = Number(address[1]);
  if (!protocols.includes(protocol)) throw Error("Address protocol should be one of: ".concat(protocols.join(', ')));
  var raw = address.slice(2);

  switch (protocol) {
    case _enums.Protocol.ID:
      {
        if (raw.length > maxInt64StringLength) throw Error('Invalid ID address length');
        if (isNaN(Number(raw))) throw Error('Invalid ID address');
        var payload = leb.unsigned.encode(raw);
        return {
          protocol: protocol,
          payload: payload,
          coinType: coinType
        };
      }

    case _enums.Protocol.DELEGATED:
      {
        var splitIndex = raw.indexOf('f');
        if (splitIndex === -1) throw new Error('Invalid delegated address');
        var namespaceStr = raw.slice(0, splitIndex);
        if (namespaceStr.length > maxInt64StringLength) throw new Error('Invalid delegated address namespace');
        var subAddrCksmStr = raw.slice(splitIndex + 1);
        var subAddrCksmBytes = base32.decode(subAddrCksmStr);
        if (subAddrCksmBytes.length < checksumHashLength) throw Error('Invalid delegated address length');
        var subAddrBytes = subAddrCksmBytes.slice(0, -checksumHashLength);
        var checksumBytes = subAddrCksmBytes.slice(subAddrBytes.length);
        if (subAddrBytes.length > maxSubaddressLen) throw Error('Invalid delegated address length');
        var protocolByte = leb.unsigned.encode(protocol);
        var namespaceNumber = Number(namespaceStr);
        var namespaceByte = leb.unsigned.encode(namespaceNumber);
        var bytes = uint8arrays.concat([protocolByte, namespaceByte, subAddrBytes]);
        if (!validateChecksum(bytes, checksumBytes)) throw Error('Invalid delegated address checksum');
        var namespaceBuf = new _nodeInt["default"](namespaceNumber).toBuffer();

        var _payload = uint8arrays.concat([namespaceBuf, subAddrBytes]);

        return {
          protocol: protocol,
          payload: _payload,
          coinType: coinType,
          namespace: namespaceNumber
        };
      }

    case _enums.Protocol.SECP256K1:
    case _enums.Protocol.ACTOR:
    case _enums.Protocol.BLS:
      {
        var payloadCksm = base32.decode(raw);
        if (payloadCksm.length < checksumHashLength) throw Error('Invalid address length');

        var _payload2 = payloadCksm.slice(0, -checksumHashLength);

        var checksum = payloadCksm.slice(_payload2.length);
        if (protocol === _enums.Protocol.SECP256K1 || protocol === _enums.Protocol.ACTOR) if (_payload2.length !== payloadHashLength) throw Error('Invalid address length');
        if (protocol === _enums.Protocol.BLS) if (_payload2.length !== blsPublicKeyBytes) throw Error('Invalid address length');

        var _protocolByte = leb.unsigned.encode(protocol);

        var _bytes2 = uint8arrays.concat([_protocolByte, _payload2]);

        if (!validateChecksum(_bytes2, checksum)) throw Error('Invalid address checksum');
        return {
          protocol: protocol,
          payload: _payload2,
          coinType: coinType
        };
      }

    default:
      throw Error("Invalid address protocall: ".concat(protocol));
  }
}
/**
 * idFromAddress extracts the ID from an ID address.
 */


function idFromAddress(address) {
  if (address.protocol() !== _enums.Protocol.ID) throw new Error('Cannot get ID from non ID address'); // An unsigned varint should be less than 2^63 which is < Number.MAX_VALUE.
  // So this number SHOULD be representable in JS and safe to parseInt.
  // https://github.com/multiformats/unsigned-varint
  // TODO: does leb128 enforce the max value?

  return parseInt(leb.unsigned.decode(address.payload()), 10);
}
/**
 * delegatedFromEthAddress derives the f410 address from an ethereum hex address
 */


function delegatedFromEthAddress(ethAddr) {
  var coinType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _coinType.CoinType.TEST;
  return newDelegatedEthAddress(ethAddr, coinType).toString();
}
/**
 * ethAddressFromDelegated derives the ethereum address from an f410 address
 */


function ethAddressFromDelegated(delegated) {
  return _ethers.utils.getAddress("0x".concat(decode(delegated).subAddrHex));
}
/**
 * ethAddressFromID derives the ethereum address from an f0 address
 */


function ethAddressFromID(idAddress) {
  var address = decode(idAddress);
  var id = idFromAddress(address);
  var buffer = new ArrayBuffer(ethAddressLength);
  var dataview = new DataView(buffer);
  dataview.setUint8(0, 255);
  dataview.setBigUint64(12, BigInt(id), false);
  return "0x".concat(uint8arrays.toString(new Uint8Array(buffer), 'hex'));
}

var _default = {
  Address: Address,
  newAddress: newAddress,
  newIDAddress: newIDAddress,
  newActorAddress: newActorAddress,
  newSecp256k1Address: newSecp256k1Address,
  newBLSAddress: newBLSAddress,
  newFromString: newFromString,
  bigintToArray: bigintToArray,
  decode: decode,
  encode: encode,
  getChecksum: getChecksum,
  validateChecksum: validateChecksum,
  validateAddressString: validateAddressString,
  checkAddressString: checkAddressString,
  idFromAddress: idFromAddress,
  delegatedFromEthAddress: delegatedFromEthAddress,
  ethAddressFromDelegated: ethAddressFromDelegated,
  CoinType: _coinType.CoinType,
  Protocol: _enums.Protocol
};
exports["default"] = _default;
//# sourceMappingURL=index.js.map