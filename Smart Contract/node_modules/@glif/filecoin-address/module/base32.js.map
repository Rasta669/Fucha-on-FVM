{"version":3,"sources":["../src/base32.ts"],"names":["uint8arrays","decode","input","alphabet","replace","RegExp","length","bits","value","index","output","Uint8Array","i","indexOf","encode","buffer","byteLength","view","padding","substring","base32","fromString","char","Error"],"mappings":"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","sourcesContent":["import * as uint8arrays from 'uint8arrays'\n\n/* tslint:disable:no-bitwise */\n// From js-multibase (https://github.com/multiformats/js-multibase)\n\nfunction decode(input: string, alphabet: string): Uint8Array {\n  input = input.replace(new RegExp('=', 'g'), '')\n  const { length } = input\n\n  let bits = 0\n  let value = 0\n\n  let index = 0\n  const output = new Uint8Array(((length * 5) / 8) | 0)\n\n  for (let i = 0; i < length; i++) {\n    value = (value << 5) | alphabet.indexOf(input[i])\n    bits += 5\n\n    if (bits >= 8) {\n      output[index++] = (value >>> (bits - 8)) & 255\n      bits -= 8\n    }\n  }\n\n  return output\n}\n\nfunction encode(\n  buffer: Uint8Array | ArrayBufferLike,\n  alphabet: string\n): string {\n  const length = buffer.byteLength\n  const view = new Uint8Array(buffer)\n  const padding = alphabet.indexOf('=') === alphabet.length - 1\n\n  if (padding) {\n    alphabet = alphabet.substring(0, alphabet.length - 2)\n  }\n\n  let bits = 0\n  let value = 0\n  let output = ''\n\n  for (let i = 0; i < length; i++) {\n    value = (value << 8) | view[i]\n    bits += 8\n\n    while (bits >= 5) {\n      output += alphabet[(value >>> (bits - 5)) & 31]\n      bits -= 5\n    }\n  }\n\n  if (bits > 0) {\n    output += alphabet[(value << (5 - bits)) & 31]\n  }\n\n  if (padding) {\n    while (output.length % 8 !== 0) {\n      output += '='\n    }\n  }\n\n  return output\n}\n\nexport function base32(alphabet: string) {\n  return {\n    encode(input: Uint8Array | string): string {\n      if (typeof input === 'string') {\n        return encode(uint8arrays.fromString(input), alphabet)\n      }\n\n      return encode(input, alphabet)\n    },\n    decode(input: string): Uint8Array {\n      for (const char of input) {\n        if (alphabet.indexOf(char) < 0) {\n          throw new Error('invalid base32 character')\n        }\n      }\n\n      return decode(input, alphabet)\n    }\n  }\n}\n"],"file":"base32.js"}